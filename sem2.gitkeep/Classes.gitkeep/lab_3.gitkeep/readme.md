***Вариант 11***

Создать класс Money для работы с денежными суммами. Число должно быть представлено двумя полями: типа long для рублей и типа int для копеек. Дробная часть числа при выводе на экран должна быть отделена от целой части запятой. Реализовать: операции сравнения (<, >). добавление копеек (++) (постфиксная и префиксная формы)

![image](https://github.com/user-attachments/assets/5bfb29c0-dcdc-4af7-a6ec-b587c1fd5e6e)


***Контрольные вопросы:***

**Для чего используются дружественные функции и классы?**

Дружественные функции и классы в C++ используются для доступа к частным и защищенным членам других классов, в которых они объявлены как друзья.

**Сформулировать правила описания и особенности дружественных функций.**

Дружественная функция объявляется внутри класса, к элементам которого ей нужен доступ, с ключевым словом friend. В качестве параметра ей должен передаваться объект или ссылка на объект класса, поскольку указатель this ей не передается.

Дружественная функция может быть обычной функцией или методом другого ранее определенного класса. На нее не распространяется действие спецификаторов доступа, место размещения ее объявления в классе безразлично.

Одна функция может быть дружественной сразу нескольким классам.

**Каким образом можно перегрузить унарные операции?**

В C++ можно перегрузить следующие унарные операторы:

! (логическое НЕ);

& (адрес);

~ (дополнение);

"*" (разыменовка указателя);

"+" (унарный плюс);

"-" (унарное отрицание);

++ (добавочный префикс) или (приращение постфикса);

-- (префикс декремент) или (postfix decrement).

**Сколько операндов должна иметь унарная функция-операция, определяемая внутри класса?**

Один.

**Сколько операндов должна иметь унарная функция-операция, определяемая вне класса?**

Один.

**Сколько операндов должна иметь бинарная функция-операция, определяемая внутри класса?**

Два.

**Сколько операндов должна иметь бинарная функция-операция, определяемая вне класса?**

Два.

**Чем отличается перегрузка префиксных и постфиксных унарных операций?**

Разница между ними заключается в возвращаемом ими значении. Перегруженные префиксные операторы возвращают объект после того, как он был инкрементирован или декрементирован. Следовательно, перегрузить их довольно просто. Мы просто увеличиваем или уменьшаем наши переменные-члены, а затем возвращаем *this. Постфиксные операторы, напротив, должны возвращать состояние объекта до его инкремента или декремента.

**Каким образом можно перегрузить операцию присваивания?**

Перегрузка оператора присваивания — это процедура копирования величин из объекта в объект.

Существует два основных способа перегрузки операторов:

С помощью функций глобального масштаба.

С помощью дружественных функций для класса или функций, которые представляют сам класс.

Перегрузку возможно делать только для классов пользователя.

**Что должна возвращать операция присваивания?**

Ссылку на объект.

**Каким образом можно перегрузить операции ввода-вывода?**

Для того, чтобы перегрузить операции ввода и вывода для пользовательского класса, необходимо перегрузить операторы для объектов класса.

**В программе описан класс class Student { … Student& operator++(); …. }; и определен объект этого класса Student s; Выполняется операция ++s; Каким образом, компилятор будет воспринимать вызов функции-операции?**

При выполнении операции ++s;, компилятор будет интерпретировать это как префиксный инкремент объекта s, используя перегруженный оператор ++ в классе Student.

**В программе описан класс class Student { … friend Student& operator ++( Student&); …. }; и определен объект этого класса Student s; Выполняется операция ++s; Каким образом, компилятор будет воспринимать вызов функции-операции?**

При выполнении операции ++s;, компилятор будет интерпретировать это как вызов дружественной функции operator++ вне класса, которая оперирует с объектом s.

**В программе описан класс class Student { … bool operator<(Student &P); …. }; и определены объекты этого класса Student a,b; Выполняется операция cout<<a<b; Каким образом, компилятор будет воспринимать вызов функции-операции?**

При выполнении операции cout << a < b;, компилятор будет интерпретировать это как вызов перегруженного оператора < для объектов a и b класса Student, который сравнивает их и возвращает булевое значение.

**В программе описан класс class Student { … friend bool operator >(const Person&, Person&) …. }; и определены объекты этого класса Student a,b; Выполняется операция cout<b; Каким образом, компилятор будет воспринимать вызов функции-операции?**

При выполнении операции cout << a > b;, компилятор будет интерпретировать это как вызов дружественной функции operator> вне класса, которая оперирует с объектами a и b класса Student и сравнивает их.
